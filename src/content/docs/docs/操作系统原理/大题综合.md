---
title : 大题综合
sidebar : 
    order : 4
---

大题主要是涵盖四个方面（去除了说了不考的PV原语）

处理机调度、银行家算法、页面置换算法、磁盘调度算法

---

## 处理机调度/进程调度
### 背景
在多道程序设计环境中，多个进程可能处于就绪状态，竞争CPU资源。处理机调度（CPU Scheduling）的任务就是根据某种策略从就绪队列中选择一个进程占用CPU，以提高系统资源利用率和响应速度。

好的调度策略可以显著提升系统性能，如缩短平均等待时间、减少上下文切换、提高吞吐量和响应及时性。

---

### 核心概念
+ **可抢占与不可抢占**：是否允许在一个进程执行期间被中断并让出CPU。
+ **作业类型**：
    - **短作业**：运行时间短，响应时间要求高。
    - **长作业**：运行时间长，适合批处理。
+ **实时性与公平性**：调度策略是否能兼顾效率与公平，是否存在“饥饿”现象。
+ **调度目标**：最大化CPU利用率，最小化平均等待时间、响应时间等。

同时还有一些衡量算法性能的指标。

+ **周转时间**：从作业提交到完成的时间。`周转时间=作业完成时间-作业提交时间`。平均周转时间，就是把作业总数的周转时间加起来除以作业个数。
+ **带权周转时间**：是指作业周转时间与作业实际运行时间的比值。`带权周转时间=作业周转时间/作业实际运行时间`
+ **等待时间**：进程等处理机的时间之和。`等待时间=作业开始时间-到达时间`，如果被抢占，则从被抢开始计算，一直到再一次开始。这包括初次到达后等待开始执行的时间和被抢占后每次重新进入就绪队列等待的时间。
+ **响应时间**：用户提交请求到首次响应的时间。也就是`首次响应时间-到达时间`

---

### 实现原理
**先来先服务（FCFS）**：按进程进入就绪队列的时间顺序执行，不可抢占。简单、公平，但不利于短作业，响应慢。

**短作业优先（SJF）**：优先执行估计运行时间最短的作业。平均等待时间最小，但长作业容易饥饿，估算时间难。

**时间片轮转（RR）**：每个作业轮流执行固定时间片，时间到则切换，适用于分时系统。公平性好，响应快，但上下文切换频繁有开销。

**多级反馈队列（MLFQ）**：多个优先级队列，优先级低的进程如果长时间未运行，逐渐上升；时间片短的队列优先调度。兼顾实时性和效率，适应性强，实现复杂。

---

### 示例
---

### 总结
| 调度策略 | 能否抢占 | 能否不可抢占 | 优点 | 缺点 | 适用于 | 默认决策模式 |
| --- | --- | --- | --- | --- | --- | --- |
| 先来先服务 | 否 | 能 | 公平，实现简单 | 不利于短作业 | 无 | 非抢占 |
| 短作业优先 | 能 | 能 | 平均等待时间最少，效率最高 | 长作业会饥饿，估计时间不易确定 | 作业调度，批处理系统 | 非抢占 |
| 时间片轮转 | 能 | 否 | 兼顾长短作业 | 平均等待时间较长，上下文切换浪费时间 | 分时系统 | 抢占 |
| 多级反馈队列 | 队列内算法不定 | 队列内算法不定 | 兼顾长短作业，有较好的响应时间，可行性强 | 无 | 相当通用 | 抢占 |


---

## 银行家算法（Banker's Algorithm）
### 背景
银行家算法用于 **避免死锁**。它设想系统如同一个银行，进程像客户，每个进程要借资源，系统要判断是否“安全”才决定是否借出，避免最终无资源可用的死锁局面。

---

### 核心概念
主要涉及四个数据结构：

+ **Available**：当前系统可用资源向量
+ **Max**：每个进程最大需求资源矩阵
+ **Allocation**：已分配给每个进程的资源矩阵
+ **Need**：每个进程仍需资源矩阵，Need = Max - Allocation

---

### 实现原理
银行家算法分为两部分：

**安全性算法（是否存在安全序列）**

遍历系统中所有进程，判断是否存在一个顺序，使每个进程都能完成：

+ 初始化：Work = Available，Finish[i] = false（表示进程i是否已完成）
+ 找到某个i满足：Finish[i] = false 且 Need[i] ≤ Work
+ 若找到，则 Work = Work + Allocation[i]，Finish[i] = true，重复上一步
+ 如果所有Finish[i]都变为true，系统处于安全状态

**资源请求算法**

当一个进程请求资源Request[i]时：

+ 若 Request[i] ≤ Need[i] 且 Request[i] ≤ Available，系统试着分配资源
+ 暂时分配后运行安全性算法，若安全，正式分配；若不安全，撤销分配，等待资源

---

### 示例
系统中有 5 个进程：`P0, P1, P2, P3, P4`  
有 3 类资源：A, B, C  
资源总量为：A = 10，B = 5，C = 7

在时间点 `T0` 的资源分配情况如下：

| 进程 | Max A B C | Allocation A B C | Available A B C |
| --- | --- | --- | --- |
| P0 | 7 5 3 | 0 1 0 | 3 3 2 |
| P1 | 3 2 2 | 2 0 0 |  |
| P2 | 9 0 2 | 3 0 2 |  |
| P3 | 2 2 2 | 2 1 1 |  |
| P4 | 4 3 3 | 0 0 2 |  |


---

**步骤一：计算 Need 矩阵**

公式：`Need = Max - Allocation`

| 进程 | Need A B C |
| --- | --- |
| P0 | 7 4 3 |
| P1 | 1 2 2 |
| P2 | 6 0 0 |
| P3 | 0 1 1 |
| P4 | 4 3 1 |


---

**步骤二：执行安全性算法（初始 Work = Available = 3 3 2）**

按步骤：

1. 找出 Need ≤ Work 的进程：
    - P1: (1 2 2) ≤ (3 3 2)
    - P3: (0 1 1) ≤ (3 3 2)
2. 任选其一（如选择 P1），释放其资源 `(2 0 0)`：
    - 新 Work = (3 3 2) + (2 0 0) = **(5 3 2)**
3. 再次查找：
    - P3: (0 1 1) ≤ (5 3 2) → 选中，释放其资源 `(2 1 1)` → Work = **(7 4 3)**
4. P4: (4 3 1) ≤ (7 4 3) → 释放 `(0 0 2)` → Work = **(7 4 5)**
5. P2: (6 0 0) ≤ (7 4 5) → 释放 `(3 0 2)` → Work = **(10 4 7)**
6. P0: (7 4 3) ≤ (10 4 7) → 安全

✅ 安全序列为：**{P1, P3, P4, P2, P0}**

---

**安全序列分析**

| 进程 | Work | Need | Allocation | Work + Allocation |
| --- | --- | --- | --- | --- |
| P1 | 3 3 2 | 1 2 2 | 2 0 0 | 5 3 2 |
| P3 | 5 3 2 | 0 1 1 | 2 1 1 | 7 4 3 |
| P4 | 7 4 3 | 4 3 1 | 0 0 2 | 7 4 5 |
| P2 | 7 4 5 | 6 0 0 | 3 0 2 | 10 4 7 |
| P0 | 10 4 7 | 7 4 3 | 0 1 0 | 10 5 7 |


---

**银行家算法资源请求判断（以 P1 为例）**

假设 `P1` 请求资源：`Request₁ = (1, 0, 2)`

**检查步骤：**

1. Request ≤ Need → `(1 0 2)` ≤ `(1 2 2)` ✅
2. Request ≤ Available → `(1 0 2)` ≤ `(3 3 2)` ✅

**执行试分配：**

```markdown
Available = Available - Request = (2 3 0)
Allocation₁ = Allocation₁ + Request = (3 0 2)
Need₁ = Need₁ - Request = (0 2 0)
```

得到新的资源状态，执行安全性算法 → 找到安全序列 **{P1, P3, P4, P2, P0}**  
✅ 系统仍安全 → 可以正式分配资源

---

**非安全示例：P₀ 请求 (0, 2, 0)**

判断：

1. Request₀ = (0 2 0) ≤ Need₀ = (7 4 3) ✅
2. Request₀ ≤ Available = (2 3 0) ✅

**执行试分配：**

```markdown
Available = (2 1 0)
Allocation₀ = (0 3 0)
Need₀ = (7 1 3)
```

**执行安全性检查：**

当前 Available = (2 1 0)  
观察所有 Need：无进程 Need ≤ Available → 无法继续  
❌ 系统进入不安全状态 → 拒绝该请求

---

### 总结
银行家算法关键：

1. 检查 Request 是否合法
2. 执行试分配并计算新 Available、Allocation、Need
3. 使用安全性算法判断系统是否安全
4. 安全才正式分配，否则拒绝

优点：严格避免死锁，逻辑严密  
缺点：效率低，要求预先知道最大需求，不适合频繁资源请求的场景

---

## 页面置换算法
### 背景
---

### 核心概念
---

### 实现原理
---

### 示例
---

### 总结
---

## 磁盘调度算法
### 背景
在操作系统中，磁盘I/O操作速度远低于内存。因此，合理安排磁盘请求的处理顺序，可以显著提升系统性能。磁盘调度算法的目标主要是减少磁头移动总距离，从而提高响应速度与整体吞吐量。

---

### 核心概念
+ **磁头位置**：当前磁盘读写头所在的柱面位置。
+ **请求队列**：待处理的磁盘请求，表示为柱面号序列。
+ **寻道时间**：磁头移动到目标柱面所需时间，取决于磁头移动的距离。
+ **饥饿（Starvation）**：某些请求长期无法得到处理。
+ **公平性**：不同请求能否被均衡响应。

---

### 实现原理
**FCFS（First Come First Serve，先来先服务）**

按照请求到达顺序进行处理，磁头不做优化，逐个处理。序列是什么顺序，就按照什么顺序。

**优点**：

+ 实现简单
+ 公平，不会饿死请求

**缺点**：

+ 磁头移动距离大，效率低
+ 无法应对负载高时的性能需求

---

**SSTF（Shortest Seek Time First，最短寻道优先）**  
每次选择距离当前磁头**最近的请求**，以最小化当前寻道时间。从当前磁头出发，一直找最近的，左跳一下，右跳一下，每次都找距离最短的。

**优点**：

+ 平均寻道时间短
+ 性能优于FCFS

**缺点**：

+ 存在饥饿问题
+ 不公平

---

**SCAN（电梯算法）**  
磁头像电梯一样向一个方向移动（如向高柱面），处理所有该方向请求后再反向。先排序，从起始磁头（中间）开始，先按顺序（磁头最小，从小到大）遍历所有大的，然后再反向（磁头最大，从大到小）。

**优点**：

+ 比FCFS平均寻道时间低
+ 公平性更好，无饥饿

**缺点**：

+ 边缘请求等待时间可能较长
+ 中心柱面响应更快，有“偏心”

---

**C-SCAN（循环扫描）**  
磁头只在一个方向（如从小到大）处理请求，回到起点时**不处理**请求，相当于环形调度。从磁头开始，一个方向处理完了（如从磁头开始从小到大），直接回到最小，再依次增大。

**优点**：

+ 响应时间更平滑，适合实时系统
+ 无饥饿问题

**缺点**：

+ 回程空转
+ 实现比SCAN复杂

---

### 示例
**FCFS示例**

+ 请求序列：82, 170, 43, 140, 24, 16, 190
+ 起始位置：50
+ 处理顺序：50 → 82 → 170 → 43 → 140 → 24 → 16 → 190
+ 总移动距离 = |50-82| + |82-170| + |170-43| + ... = **642**

**分析原因**：  
该方法**不优化路径**，所以磁头在请求之间可能大幅度跳跃，如170跳到43，造成寻道时间增加。

---

**SSTF示例**

+ 请求序列：82, 170, 43, 140, 24, 16, 190
+ 起始位置：50
+ 处理顺序：50 → 43 → 24 → 16 → 82 → 140 → 170 → 190
+ 总移动距离 = |50-43| + |43-24| + ... = **208**

**分析原因**：  
始终处理**最短路径**，磁头局部移动，减少平均寻道时间。但远处请求如190会延迟处理，可能被“饿死”。

---

**SCAN示例**

+ 请求序列：82, 170, 43, 140, 24, 16, 190
+ 起始位置：50，向上移动
+ 处理顺序：50 → 82 → 140 → 170 → 190 → （反向）→ 43 → 24 → 16
+ 总移动距离 = |50-82| + ... + |190-43| + ... = **332**

**分析原因**：  
磁头**顺序移动**，减少随机跳动，但远端请求仍需等待整趟运行完成。

---

**C-SCAN示例**

+ 请求序列：82, 170, 43, 140, 24, 16, 190
+ 起始位置：50，向上移动
+ 处理顺序：50 → 82 → 140 → 170 → 190 → （返回）→ 16 → 24 → 43
+ 总移动距离 = |50-82| + ... + |190-0| + |0-16| + ... = **376**

**分析原因**：  
强制回到起点，牺牲一部分效率换来**请求响应时间的一致性**，适用于对实时性要求较高的系统。

---

### 总结
| 算法 | 平均寻道时间 | 公平性 | 是否可能饥饿 | 实现复杂度 | 适用场景 |
| --- | --- | --- | --- | --- | --- |
| FCFS | 较高 | 高 | 否 | 最简单 | 请求少或实时性低系统 |
| SSTF | 最优或较低 | 差 | 是 | 一般 | 追求效率的非实时系统 |
| SCAN | 中等 | 较高 | 否 | 中等 | 通用系统 |
| C-SCAN | 稳定 | 高 | 否 | 略复杂 | 实时或公平性要求高 |




